# 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴

## 1장

### 객체의 책임과 크기

객체는 객체 마다 서로 다른 책임을 지닌다.

이러한 책임은 처음부터 정해진 것이 아니라, 처음에 프로그램을 개발할 때 기능에 대해 미리 정의해 놓고 해당 기능에 대한 책임을 어떤 객체가 지닐 지에 대해 정하는 것이다.

### 객체 지향의 설계 과정

1. 제공해야 할 기능을 찾거나 세분화하고, 그 기능을 알맞은 객체에 할당한다.

- 기능을 구현하는 데 필요한 데이터(멤버변수)를 객체에 추가한다. 데이터를 먼저 만든 후 그 데이터에 해당하는 기능을 만들 수도 있다.
- 기능은 최대한 캡슐화하여 구현한다.

2. 객체간에 어떻게 메시지를 주고받을지 결정한다.
3. 과정 1과 2를 개발하면서 계속 반복한다.

## 2장

### 단일 책임 원칙

> 클래스는 단 하나만의 책임만 가져야 한다.

책임이 커질수록 그에 따라 연쇄적인 코드 수정이 일어나게 되고 재사용이 어렵게 된다.

### 개방 폐쇄 원칙

> 확장에는 열려있고 변경에는 닫혀 있어야 한다.

새로운 기능이 추가되면 기존 코드는 수정하지 않으면서 새 코드만 추가할 수 있게 하는 것이 핵심이다.

### 리스코프의 치환 원칙

> 상위 타입의 객체를 하위 타입의 객체로 교체해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

타입을 확인하는 기능, instanceof 메서드를 사용하게 된다면 이 원칙을 위반할 때 발생하는 현상이다. 이때는 추상화가 잘 되었는지 확인하자.

리스코프의 치환 원칙을 위반하면 개방 폐쇄 원칙도 위반하게 된다. 개방 폐쇄 원칙을 위반하면 기능을 추가할 때 많은 부분을 수정해야 하기 때문에, 리스코프의 치환 원칙을 지키지 않으면 기능을 확장하기 어렵게 된다.

### 인터페이스 분리 원칙

> 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

각 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리함으로써, 클라이언트로부터 발생한느 인터페이스 변경의 여파가 다른 클라이언트에 미치는 영향을 최소화할 수 있게 된다.

### 의존 역전 원칙

> 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

- 고수준 모듈은 어떤 의미 있는 기능을 제공하는 모듈
- 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현

고수준 모듈은 상대적으로 큰 틀, 저수준 모듈은 각 개별 요소가 어떻게 구현될지에 대해 다룬다.

추상화를 통해 새로운 추상 타입을 만들고, 고수준 모듈과 저수준 모듈 모두 추상 타입에 의존하게 하여 두 관계를 완화할 수 있다.

### 어플리케이션 영역과 메인 영역

로버트 C 마틴은 소프트웨어를 두개의 영역으로 나누었다.

고수준 정책 및 저수준 구현을 포함한 어플리케이션 영역과, 어플리케이션이 수행하도록 각 개체를 연결해주는 메인 영역으로 나뉜다.

이 중 메인 영역은 다음과 같은 작업을 수행한다.

- 어플리케이션 영역에서 사용될 객체를 생성한다.
- 각 객체 간의 의존 관계를 설정한다.
- 어플리케이션을 실행한다.

### Dependency Injection

사용할 객체를 직접 생성할 경우, 콘크리트 클래스에 대한 의존이 발생한다.

DI는 필요한 객체를 직접 생성하지 않고 외부에서 넣어주는 방식을 제공한다.

## DI 와 서비스 로케이터

### DI

DI를 사용하면, 테스트 할때 의존하는 클래스가 구현되지 않았더라도 Mock 객체를 생성자나 설정 메서드에 넣어줌으로써 해당 클래스가 정상적으로 동작하는지 확인할 수 있다.

스프링 프레임워크의 config.xml 파일을 통해 xml파일에 설정된 객체를 생성하고 조립할 수 있다. 스프링 프레임워크는 이런 조립기의 역할을 수행한다.
Xml 파일 방식은 자바 코드 수정 및 컴파일 과정이 필요가 없지만, 오타를 잡기 힘든 등의 단점이 있어 스프링 3버전부터는 자바 코드 기반 설정 방식이 추가되었다. (@Configuration, @Bean)

```java
@Configuration
public class TrascoderConfig {

  @Bean
  public JobQueue fileJobQueue() {
    return new FileJobQueue();
  }

  // ...
}
```

### 서비스 로케이터

서비스 로케이터의 단점은 인터페이스 분리 원칙을 위반할 수 있다는 것이다. (서비스 로케이터에서 여러 타입을 사용) 그래서 이를 해결하기 위해 의존 객체마다 서비스 로케이터를 작성하는 방법도 있지만, 제네릭 기반의 객체 등록 방식으로 어느 정도 해소할 수 있다.
그러나 가장 큰 단점은 동일 타입의 객체가 다수 필요할 경우 각 객체 별로 제공 메서드를 만들어야 한다(!!)

## 주요 디자인 패턴

반복적으로 사용되는 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖는다.

### 전략 패턴 - Strategy

전략 패턴을 사용할 때 얻을 수 있는 이점은 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점이다. 새로운 전략을 추가할 때 기존 코드는 변경되지 않으므로 OCP 정책을 잘 지킬 수 있다.

비슷한 코드를 실행하는 if-else 블록은 전략 패턴의 적용 대상이다. 또한, 동일한 기능을 제공하지만 성능의 장단점에 따라 알고리즘을 선택해야 하는 경우에도 전략 패턴을 사용한다.

### 템플릿 메서드 패턴 - Template Method

단계 중 일부의 구현이 다른 경우 사용할 수 있는 패턴이 템플릿 메서드 패턴이다. 템플릿 메서드 패턴은 다음과 같이 두 가지로 구성된다.

- 실행 과정을 구현한 상위 클래스
- 실행 과정의 일부 단계를 구현한 하위 클래스

템플릿 메서드 패턴을 사용하게 되면, 동일한 실행 과정의 구현을 제공하면 동시에 하위 타입에서 일부 단계를 구현하게 할 수도 있다.

상위 클래스가 흐름 제어를 주체한다는 특징이 있다.

### 상태 패턴 - State

기능이 상태에 따라 다르게 동작해야 할 때 사용할 수 있는 패턴이 상태 패턴이다. 상태 패턴에서는 상태를 별도 타입으로 분리하고, 각 상태 별로 알맞은 하위 타입을 구현한다.

상태 패턴은 새로운 상태가 추가되어도 콘텍스트 코드가 받는 영향은 최소화되고, 상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기에 상태 별 동작을 수정하기 쉽다.

상태를 변경하는 것은 콘텍스트 객체가 할 수도, 상태 객체가 할 수도 있다. 둘은 명확한 장단점을 가지므로 상황에 따라 선택하는게 좋다.

콘텍스트 객체에서 상태를 변경

- 비교적 상태 개수가 적고 규칙이 거의 바뀌지 않을 때
  - 상태 종류가 지속적으로 변경되거나 규칙이 자주 바뀌면 상태 변경 처리가 복잡해짐

상태 객체에서 상태를 변경

- 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 규칙 변경 가능
- 다만 상태 변경 규칙이 여러 클래스에 분리되어 있어 상태 변경 규칙 파악이 힘듦
